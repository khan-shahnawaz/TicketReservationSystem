# TicketReservationSystem

## Setup

- Clone the repository and cd into the folder containing setup.sql
- Start the postgresql by the following commands:
```
sudo -s -u postgres
psql
```
- Now load the tables and procedures by the command
```
\i setup.sql
```

## Relations

- trains (**number**, name)
    - **number**: Can be any integer between 0 and 99999. Should be unique for each train.
    - Name: A string representing name of the train. Can be atmost 50 characters long
    
- runs (**train_number**, **departure_date**, ac_coach, sleeper_coach)
    - **train_number**: Foreign key denoting number of train from trains relation.
    - **departure_date**: Represents date of departure of train in YYYY-MM-DD format. Date should be enclosed with ''(single quotes) while inserting any record.
    - ac_coach: Number of AC coaches on the train on that particular day.
    -sleeper_coach: Number of Sleeper coaches on the train on that particular day.
    
- tickets (PNR, train_number, journey_date, passenger_name, coach, berth_type, berth_number)
    - PNR: A 19 characters long string consisting of numbers only, auto-generated by the application while booking tickets. Same for all passengers booking together.
    - journey_date: Date of journey in the format YYYY-MM-DD.
    - passenger_name: Name of passenger. Can be atmost 16 characters long.
    - coach: Coach number can vary from A1-A999 and S1-S999. A denotes AC coach and S denotes Sleeper coach. Stored as CHAR(4).
    - berth_type: Can be LB, UB, MB, SL, SU
    - berth_number: An integer denoting berth number of the concerned passenger. Varies from 1-18 in AC coach and 1-24 in Sleeper Coaches.

## Stored Procedures and Functions

- add_train(train_number, train_name)

    - Description: Takes the number and name of train and adds the entry into the trains relation(Format of trains relations should be strictly followed)
    
- release_into_booking(train_no ,dep_date , num_ac_coach ,num_sleeper_coach)
    - Description: The argument names are self-explainatory. Format of runs relation should be followed. Same train cannot run twice on the same day. It creates two tables, one each for sleeper and AC coaches and fill it with seats based on number of ac and sleeper coaches provided. Also it inserts corresponding entry in the runs relation.
    
- book_tickets(num_passengers , coach_type , train_no , journey_date , first_try ,name1, name2, .... )
    - num_passengers: It is an integer. It can be any number. Sufficient number of names must be given at the end of arguments for the function to execute correctly.
    - coach_type: Can be 'A' or 'S' for the choice of AC and Sleeper respectively.
    - train_no: Train number in the same format as in trains relation.
    - journey_date: Date of journey chosen by the passengers in the format 'YYYY-MM-DD'.
    - first_try: Can be 'true' or 'false'. It's use is  described below.
    - name1, name2... : Names of passenger in the end seperated by comma. Must be equal to num_passengers. 
    - How it works
        - Output Format: Array {EXIT CODE, PNR, berth_number1, coach1, berth_type1, berth_number2, coach2, berth_type2.....}
            - The order of berth_number, coach and berth_type is same for the passenger as in the arguments.
            - Note that coach number will be an integer. 'A' or 'S'(Depending on AC or Sleeper) has to be padded on the left before sending the tickets to the passenger.
            - If ticket is not booked due to any reason, only one element is there in the output array. i.e ARRAY {EXIT CODE}.
        - It takes the input in the format specified above. In the first attempt, first_try is 'true'.
        - First it checks whether the train is released into the booking system or not. If not booking is failed with EXIT CODE -1.
        - Then it checks whether there are enough seats(locked or unlocked) in the system. If not, booking is failed with exit code -2.
        - Then, it tries to lock the rows to book the seats. If it is not able to lock enough rows, it returns with EXIT CODE -3. If it returns with this EXIT CODE, then application should retry calling the same function again with same arguments but first_try = 'false'. This time, it will try to lock the entire table and it is guaranteed that it will return with EXIT CODE -2 or EXIT CODE 0 this time.
        - If it able to acquire locks for enough rows, then booking is successful and it will return with EXIT CODE 0 and will have other details like PNR, coach and berth of all passengers in the output array. The corresponding rows will be deleted from the table so that others cannot book the same ticket. Corresponding entries will be added in the tickets relation.
        